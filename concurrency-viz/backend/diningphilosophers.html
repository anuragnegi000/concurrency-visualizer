<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dining Philosophers Visualization</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/aos@2.3.1/dist/aos.css" rel="stylesheet">
  <style>
    #circle {
      position: relative;
      width: 500px;
      height: 500px;
      margin: 50px auto;
      background: #f8f9fa;
      border-radius: 50%;
      border: 2px solid #dee2e6;
    }

    .philosopher {
      position: absolute;
      width: 60px;
      height: 60px;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      border: 3px solid transparent;
      cursor: pointer;
      transition: border-color 0.3s;
    }

    .chopstick {
      position: absolute;
      width: 20px;
      height: 50px;
      transform: translate(-50%, -50%) rotate(25deg);
      transition: filter 0.3s, border 0.3s;
    }

    .chopstick.taken {
      filter: brightness(50%);
      border: 2px solid #198754;
    }

    .bowl {
      position: absolute;
      width: 30px;
      height: 30px;
      transform: translate(-50%, -50%);
    }

    .status {
      position: absolute;
      text-align: center;
      font-size: 14px;
      transform: translate(-50%, 0);
    }

    .lock-icon {
      position: absolute;
      display: flex;
      align-items: center;
      font-size: 12px;
      background: rgba(255, 255, 255, 0.9);
      padding: 4px 6px;
      border-radius: 6px;
      box-shadow: 0 0 4px rgba(0, 0, 0, 0.2);
    }

    .lock {
      width: 20px;
      height: 20px;
      margin-right: 5px;
    }

    .info-box {
      text-align: center;
      font-weight: bold;
      margin-top: 20px;
      font-size: 1.2rem;
      color: #0d6efd;
    }

    .error {
      color: red;
      margin-top: 10px;
      font-weight: bold;
      text-align: center;
    }
  </style>
</head>
<body class="bg-light">

<div class="container text-center mt-4">
  <h1 class="text-primary">Dining Philosophers Visualization</h1>

  <div class="form-inline">
    <label for="philosopherCount" class="form-label fw-bold">Number of Philosophers (1-5):</label>
    <input type="number" id="philosopherCount" class="form-control w-auto" min="1" max="5" value="5">
    <button onclick="startSimulation()" class="btn btn-success">Create Table</button>
  </div>

  <div class="info-box" id="infoBox">Click on a philosopher to make them eat</div>
  <div class="error" id="errorBox"></div>

  <div id="circle" class="shadow mt-4"></div>
</div>

<script>
let philosophers = [];
let chopsticks = [];
let locks = [];
let states = [];
let waitCounts = [];
let infoBox, errorBox;

function createCircle(count) {
  const circle = document.getElementById('circle');
  circle.innerHTML = '';
  philosophers = [];
  chopsticks = [];
  locks = Array(count).fill(false);
  states = Array(count).fill('thinking');
  waitCounts = Array(count).fill(0);
  infoBox = document.getElementById('infoBox');
  errorBox = document.getElementById('errorBox');

  const angleStep = 360 / count;
  const radius = 200;

  for (let i = 0; i < count; i++) {
    const angle = angleStep * i;
    const x = radius * Math.cos((angle * Math.PI) / 180);
    const y = radius * Math.sin((angle * Math.PI) / 180);

    const img = document.createElement('img');
    img.src = `assets/p${i + 1}.png`;
    img.className = 'philosopher';
    img.style.left = `${250 + x}px`;
    img.style.top = `${250 + y}px`;
    img.id = `P${i}`;
    img.alt = `Philosopher ${i + 1}`;
    img.onclick = () => handlePhilosopherClick(i);
    circle.appendChild(img);
    philosophers.push(img);

    const status = document.createElement('div');
    status.className = 'status';
    status.id = `status${i}`;
    status.style.left = `${250 + x}px`;
    status.style.top = `${250 + y + 50}px`;
    status.innerText = `P${i + 1}: Thinking üí≠`;
    circle.appendChild(status);

    const bowl = document.createElement('img');
    bowl.src = 'assets/bowl.jpg';
    bowl.className = 'bowl';
    bowl.style.left = `${250 + x + 40}px`;
    bowl.style.top = `${250 + y}px`;
    circle.appendChild(bowl);

    const chop = document.createElement('img');
    chop.src = 'assets/chopstick.jpg';
    chop.className = 'chopstick';
    chop.id = `C${i}`;
    const chopRadius = radius - 40;
    const cx = chopRadius * Math.cos(((angle + angleStep / 2) * Math.PI) / 180);
    const cy = chopRadius * Math.sin(((angle + angleStep / 2) * Math.PI) / 180);
    chop.style.left = `${250 + cx}px`;
    chop.style.top = `${250 + cy}px`;
    circle.appendChild(chop);
    chopsticks.push(chop);

    const lockIconContainer = document.createElement('div');
    lockIconContainer.className = 'lock-icon';
    const lockRadius = radius + 70;
    const lockX = lockRadius * Math.cos(((angle + angleStep / 2) * Math.PI) / 180);
    const lockY = lockRadius * Math.sin(((angle + angleStep / 2) * Math.PI) / 180);
    lockIconContainer.style.left = `${250 + lockX}px`;
    lockIconContainer.style.top = `${250 + lockY}px`;

    const lockImg = document.createElement('img');
    lockImg.src = 'assets/unlock.png';
    lockImg.className = 'lock';
    lockImg.id = `lock${i}`;

    const lockText = document.createElement('div');
    lockText.className = 'lock-text';
    lockText.id = `lockText${i}`;
    lockText.innerText = 'Mutex: Unlocked';
    lockText.style.marginLeft = '8px';

    lockIconContainer.appendChild(lockImg);
    lockIconContainer.appendChild(lockText);
    circle.appendChild(lockIconContainer);
  }

  errorBox.innerText = '';
  infoBox.innerText = 'Click on a philosopher to start or stop eating';
}

function handlePhilosopherClick(i) {
  const count = philosophers.length;
  const left = (i + count - 1) % count; // Correct left chopstick
  const right = i;                      // Correct right chopstick

  if (states[i] === 'eating') {
    locks[left] = false;
    locks[right] = false;
    updateChopstick(left, false);
    updateChopstick(right, false);
    updateState(i, 'thinking');
    updateStatus(i, `P${i + 1}: Thinking üí≠`);
    states[i] = 'thinking';
    waitCounts[i] = 0;
    infoBox.innerText = `Philosopher ${i + 1} stopped eating and is thinking.`;
  } else if (!locks[left] && !locks[right]) {
    locks[left] = true;
    locks[right] = true;
    updateChopstick(left, true);
    updateChopstick(right, true);
    updateState(i, 'eating');
    updateStatus(i, `P${i + 1}: Eating üçú`);
    states[i] = 'eating';
    waitCounts[i] = 0;
    infoBox.innerText = `Philosopher ${i + 1} is eating.`;
  } else {
    updateState(i, 'waiting');
    updateStatus(i, `P${i + 1}: Waiting üïì`);
    states[i] = 'waiting';
    waitCounts[i]++;
    infoBox.innerText = `Philosopher ${i + 1} is waiting for chopsticks.`;
  }

  detectDeadlock();
  detectStarvation();
}


function detectDeadlock() {
  const allWaiting = states.every(state => state === 'waiting');
  const noChopsticksFree = locks.every(lock => lock);
  if (allWaiting && noChopsticksFree) {
    errorBox.innerText = "‚ö†Ô∏è DEADLOCK: All philosophers are waiting and no chopsticks are free!";
  }
}

function detectStarvation() {
  const starved = waitCounts.findIndex(count => count >= 5);
  if (starved !== -1) {
    errorBox.innerText = `‚ö†Ô∏è STARVATION: Philosopher ${starved + 1} has been waiting too long!`;
  }
}

function updateState(index, state) {
  const p = document.getElementById(`P${index}`);
  p.style.borderColor = {
    'thinking': '#0d6efd',
    'eating': '#198754',
    'waiting': '#fd7e14'
  }[state] || 'transparent';
}

function updateStatus(index, text) {
  const status = document.getElementById(`status${index}`);
  if (status) status.innerText = text;
}

// üîß Chopstick UI + lock state update
function updateChopstick(index, taken) {
  const c = document.getElementById(`C${index}`);
  const lockIcon = document.getElementById(`lock${index}`);
  const lockText = document.getElementById(`lockText${index}`);

  if (c) c.classList.toggle('taken', taken);
  if (lockIcon && lockText) {
    lockIcon.src = taken ? 'assets/lock.png' : 'assets/unlock.png';
    lockText.innerText = taken ? 'Mutex: Locked' : 'Mutex: Unlocked';
  }
}

function startSimulation() {
  const count = parseInt(document.getElementById('philosopherCount').value);
  if (count < 1 || count > 5) {
    alert("Please enter a number between 1 and 5.");
    return;
  }
  createCircle(count);
}
</script>




<div class="container mt-5">
  <div class="card border-info shadow">
    <div class="card-header bg-info text-white fw-bold">
      üß† Dining Philosophers Explanation
    </div>
    <div class="card-body text-start">
      <p>
        The <strong>Dining Philosophers Problem</strong> was introduced by <em>E. W. Dijkstra</em>. It illustrates the
        challenges of <strong>concurrent programming</strong> with shared resources.
      </p>

      <h5>üçù The Setup</h5>
      <ul>
        <li>Five philosophers sit around a circular table.</li>
        <li>Each philosopher alternates between <strong>thinking</strong> and <strong>eating</strong>.</li>
        <li>There are only <strong>five chopsticks</strong> (shared between adjacent philosophers).</li>
        <li>A philosopher needs <strong>two chopsticks</strong> (left and right) to eat.</li>
      </ul>

      <h5>üîí How It Works in This Simulation</h5>
      <ul>
        <li>Each philosopher is represented by a <strong>thread</strong>.</li>
        <li>Each chopstick is protected by a <strong>mutex lock</strong>.</li>
        <li>To eat, a philosopher locks their <strong>left</strong> and <strong>right</strong> chopsticks.</li>
        <li>After eating, they <strong>unlock</strong> both chopsticks and return to thinking.</li>
      </ul>

      <h5 class="text-danger">‚ö†Ô∏è Deadlock</h5>
      <p>
        A <strong>deadlock</strong> can happen when:
        <ul>
          <li>All philosophers pick up their <strong>left chopstick</strong> at the same time.</li>
          <li>Each waits for the right chopstick, which is already held by their neighbor.</li>
          <li>This forms a <strong>circular wait</strong> ‚Äî no one can proceed.</li>
        </ul>
        <strong>Result:</strong> All philosophers are stuck. No one eats.
      </p>

      <h5 class="text-warning">‚ö†Ô∏è Starvation</h5>
      <p>
        <strong>Starvation</strong> occurs when:
        <ul>
          <li>Some philosophers are <em>faster</em> (think/eat quickly).</li>
          <li>They keep acquiring chopsticks before others get a chance.</li>
          <li>Slower philosophers <strong>wait indefinitely</strong> despite the system not being deadlocked.</li>
        </ul>
        <strong>Result:</strong> Some philosophers never get to eat ‚Äî even though chopsticks are occasionally free.
      </p>

      <h5>üìò Simulation Goals</h5>
      <ul>
        <li>Visualize thread-based concurrency and resource sharing.</li>
        <li>Observe real-time deadlock and starvation issues.</li>
        <li>Experiment with custom rules to prevent these problems.</li>
      </ul>

      <p class="mt-3">
        üëâ Try to <strong>click the philosophers</strong> and watch how chopsticks are picked up and released.
        Can you trigger a deadlock or see starvation happening?
      </p>
    </div>
  </div>
</div>

</body>
</html>
